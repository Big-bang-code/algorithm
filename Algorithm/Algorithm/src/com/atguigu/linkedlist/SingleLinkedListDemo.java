package com.atguigu.linkedlist;

import java.util.Stack;

/**
 * 单链表
 * 
 * @Title SingleLinkedList.java
 * @Description
 * @author 孟BIG
 * @date2019年8月6日
 */

public class SingleLinkedListDemo {
	public static void main(String[] args) {
		// 进行测试：
		// 1.先创建几个节点
		HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
		HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
		HeroNode hero3 = new HeroNode(3, "吴用", "智多星");

		// 2.创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();
		// 加入
//		singleLinkedList.add(hero1);
//		singleLinkedList.add(hero2);
//		singleLinkedList.add(hero3);

		singleLinkedList.addByOrder(hero1);
		singleLinkedList.addByOrder(hero3);
		singleLinkedList.addByOrder(hero2);
		singleLinkedList.addByOrder(hero2);

		// 测试修改节点的代码

		HeroNode newHeroNode = new HeroNode(2, "小卢", "玉儿");
		singleLinkedList.update(newHeroNode);

		singleLinkedList.list();
		System.out.println("*********");

//		System.out.println(singleLinkedList.getClass().getClass());
//		System.out.println(hero1.next);
//		System.out.println(hero2);

		singleLinkedList.del(2);
		singleLinkedList.list();

		//测试求单链表中的有效节点的个数
		System.out.println(getLength(singleLinkedList.getHead()));
		
		//测试是否得到倒数第k个节点
		HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 1);
		System.out.println(res);
		
		//测试反转		
		System.out.println("反转");
		//reversetList(singleLinkedList.getHead());
		
		//测试逆序打印www
		reversePrint(singleLinkedList.getHead());
		
	}

	// 方法：获取单链表的节点的个数() 如果是带头节点的链表，需要不统计头节点
	/**
	 * 
	 * Title:getLength
	 * 
	 * @return 返回有效个数的节点
	 */
	public static int getLength(HeroNode head) {
		if (head.next == null) {
			return 0;
		}
		int length = 0;
		// 这里没有统计头节点
		HeroNode cur = head.next;
		while (cur != null) {
			length++;
			cur = cur.next;// 遍历
		}
		return length;
	}
	
	//查找单链表的倒数第k个节点
	//思路
	//1.编写一个方法，接收head节点，同时接收一个index
	//2.index表示是倒数第index个节点
	//3.先把链表从头到尾遍历，得到链表的总的长度size------->getlength
	//4.得到size后，我们从链表第一个开始遍历(size-index)个
	//5.如果找到了，则返回该节点，否则返回null
	public static HeroNode findLastIndexNode(HeroNode head,int index) {
		//判断，如果链表为空，返回null
		if(head.next == null) {
			return null;//没有找到
		}
		//第一个遍历得到链表的长度(节点个数)
		int size = getLength(head);
		//第二次遍历 size-index位置，这就是倒数的第k个节点
		//先做一个index的校验
		if(index<=0||index>size) {
			return null;
		}
		//定义一个辅助变量,for循环定位到倒数的index
		HeroNode cur = head.next;
		for(int i=0;i<size-index;i++) {
			cur = cur.next;
		}
		return cur;
		
	}
	
	//反转单链表
	public static void reversetList(HeroNode head) {
		//如果当前链表为空，或只有一个节点，无需反转，直接返回
		if(head.next == null || head.next.next ==null) {
			return;
		}
		//定义一个辅助指针(变量)，帮助我们遍历原来的链表
		HeroNode cur = head.next;
		HeroNode next = null;//指向当前节点[cur]的下一个节点
		HeroNode reverseHead = new HeroNode(0,"","");//该空节点用于接收反转的节点
		
		//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端
		while(cur!=null) {
			next = cur.next;//先暂时保存当前节点的下一个节点，因为后面要用
			cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端
			reverseHead.next = cur;
			cur = next;//让cur后移
		}
		//将head.next指向reversetList.next,实现单链表的反转
		head.next = reverseHead.next;
	}
	
	//从尾到头打印单链表：要求：方式一：反向遍历，  方式二  Stack栈
	// 方式1： 先将单链表进行反转操作，然后再遍历即可，这样的做的问题是会破坏原来的单链表的结构，不建议
	//方式2：可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果.举例演示栈的使用 Stack 
	
	public static void reversePrint(HeroNode head) {
		if (head.next == null) {
			return;//空链表
		}
		//创建一个栈，将各个节点压入栈中
		Stack<HeroNode> stack = new Stack<HeroNode>();
		HeroNode cur= head.next;
		//将链表的所有节点压入栈中
		while(cur != null) {
			stack.push(cur);
			cur = cur.next;//让cur后移，这样就可以压入下一个节点
		}
		//将栈中的节点进行打印，pop出栈
		while(stack.size()>0) {
			System.out.println(stack.pop());//stack的特点是先进后出
		}
	}
	
}




//2.定义SingleLinkedList   管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动,不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	// 返回头节点
	public HeroNode getHead() {
		return head;
	}

	// 添加节点到单向链表
	// 思路：当不考虑编号顺序时
	// 1.找到当前链表的最后节点
	// 2.将最后这个节点的next 指向新的节点
	public void add(HeroNode heroNode) {
		// 因为头节点不能动，因此，我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表最后
			if (temp.next == null) {
				//
				break;
			}
			// 如果没有找到，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环时，temp就指向了链表的最后
		// 将最后这个节点的next 指向新的节点
		temp.next = heroNode;
	}

	// 第二种方式添加英雄，根据排名将英雄插入到指定位置
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们任然通过一个辅助指针来帮助找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// 标识添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp到了链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;
			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true;// 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历当前链表
		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄的编号%d已经存在，不能添加\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}
	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 根据newHeroNode 的 no来修改即可
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 标识是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 遍历完毕
			}
			if (temp.no == newHeroNode.no) {
				flag = true;
				break;
			}
			temp = temp.next;
		}
		// 根据flag判断是否找到要修改的节点
		if (flag) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {
			System.out.printf("没有找到编号 %d 的节点,不能修改\n", newHeroNode.no);
		}
	}

	// 删除节点
	// 思路：
	// 1.head不能动，因此需要temp辅助节点找到待删除节点的前一个节点
	// 2.我们在比较时，是temp.next.no和需要删除的节点的no进行比较
	public void del(int no) {
		HeroNode temp = head;
		boolean flag = false;// 标志是否找到待删除节点
		while (true) {
			if (temp.next == null) {// 已经到链表的最后
				break;
			}
			if (temp.next.no == no) {
				// 找到了待删除节点的前一个节点
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}
		// 判断flag
		if (flag) {
			// 找到，可以删除
			temp.next = temp.next.next;
		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}
	}

	// 显示链表:遍历------>通过一个辅助变量，帮助遍历整个链表
	public void list() {
		// 先判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 不为空，因为头节点不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			if (temp == null) {
				//
				break;
			}
			// 输出节点的信息
			System.out.println(temp.toString());
			// 将temp后移,否则死循环
			temp = temp.next;

		}
	}

}

//1.定义一个HeroNode，每个HeroNode对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点的域

	// 构造器
	public HeroNode(int hNo, String hName, String hNickname) {
		this.no = hNo;
		this.name = hName;
		this.nickname = hNickname;
	}

//	@Override
//	public String toString() {
//		return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname + ", next=" + next + "]";
//	}

	// 为了显示方便，重写toString
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname + "]";
	}

}